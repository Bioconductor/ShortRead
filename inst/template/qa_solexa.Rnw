\documentclass{article}

\usepackage{Sweave}

\begin{document}

\title{Solexa QA report}
\date{\today{}}
\maketitle{}

\section{Setup}

<<setup>>=
options(digits=3)
library(ShortRead)
library(lattice)
@

<<utilities, echo=FALSE>>=
ppnCount <- function(m) {
    ## scale subsequent columns to be proportions of 
    ## first column
    m[,-1] <- m[,-1] / m[,1]
    m
}
.laneLbl <- function(lane) sub("s_(.*)_.*", "\\1", lane)
plotReadQuality <- function(df) {
    df$lane <- .laneLbl(df$lane)
    xyplot(density~quality|lane, df,
           type="l",
           xlab="Average (calibrated) base quality",
           ylab="Proportion of reads",
           aspect=2)
}
plotReadOccurrences <- function(df, ...) {
    df$lane <- .laneLbl(df$lane)
    df$cummulative <- 
        with(df, unlist(tapply(nOccurrences * nReads, lane, function(elt) {
           cs <- cumsum(elt)
           (cs-cs[1] + 1)/ diff(range(cs))
        })))
    xyplot(cummulative~log10(nOccurrences)|lane, df,
           xlab=expression(paste(
               "Number of occurrences of each read (",
               log[10], ")", sep="")),
           ylab="Cummulative proportion of reads",
           aspect=2, type="l", ...)
}
freqSequences <- function(qa, read, n=20)
{
    cnt <- qa[["readCounts"]]
    df <- qa[["frequentSequences"]]
    df1 <- df[df$type==read,]
    df1[["ppn"]] <- df1[["count"]] / cnt[df1[["lane"]], read]
    head(df1[order(df1$count, decreasing=TRUE),
             c("sequence", "count", "lane")], n)
}
plotAlignQuality <- function(df) {
    df$lane <- .laneLbl(df$lane)
    xyplot(count~score|lane, df,
           type="l",
           prepanel=function(x, y, ...) {
               list(ylim=c(0, 1))
           },
           panel=function(x, y, ...) {
               panel.xyplot(x, y/max(y), ...)
           },
           xlab="Alignment quality score",
           ylab="Number of alignments, relative to lane maximum",
           aspect=2)
}

.plotTileLocalCoords <- function(tile, nrow) {
    row <- 1 + (tile - 1) %% nrow
    col <- 1 + floor((tile -1) / nrow)
    row[col%%2==0] <- nrow + 1 - row[col%%2==0]
    list(row=as.integer(row), col=as.factor(col))
}

.atQuantile <- function(x, breaks)
{
    at <- unique(quantile(x, breaks))
    if (length(at)==1)
        at <- at * c(.9, 1.1)
    at
}

.colorkeyNames <- function(at, fmt) {
    paste(names(at), " (", sprintf(fmt, at), ")", sep="")
}

plotTileCounts <- function(df, nrow=100) {
    df <- df[!is.na(df$count),]
    xy <- .plotTileLocalCoords(df$tile, nrow)
    df[,names(xy)] <- xy
    at <- .atQuantile(df$count, seq(0, 1, .1))
    df$lane <- .laneLbl(df$lane)
    levelplot(cut(count, at)~col*row|lane, df,
              main="Read count (percentile rank)",
              xlab="Tile x-coordinate",
              ylab="Tile y-coordinate",
              cuts=length(at)-2,
              colorkey=list(
                labels=.colorkeyNames(at, "%d")),
              aspect=2)
}
plotTileQualityScore <- function(df, nrow=100) {
    df <- df[!is.na(df$score),]
    xy <- .plotTileLocalCoords(df$tile, nrow)
    df[,names(xy)] <- xy
    at <- .atQuantile(df$score, seq(0, 1, .1))
    df$lane <- .laneLbl(df$lane)
    levelplot(cut(score, at)~col*row|lane, df,
              main="Read quality (percentile rank)",
              xlab="Tile x-coordinate",
              ylab="Tile y-coordinate",
              cuts=length(at)-2,
              colorkey=list(
                labels=.colorkeyNames(at, "%.2f")),
              aspect=2)
}
plotCycleBaseCall <- function(df) {
    col <- rep(c("red", "blue"), 2)
    lty <- rep(1:2, each=2)
    df <- df[df$Base != "N",]
    df$lane <- .laneLbl(df$lane)
    xyplot(log10(Count)~as.integer(Cycle)|lane, 
           group=factor(Base), df, 
           type="l", col=col, lty=lty,
           key=list(space="top", 
             lines=list(col=col, lty=lty),
             text=list(lab=as.character(unique(df$Base))),
             columns=length(unique(df$Base))),
           xlab="Cycle", 
           aspect=2)
}
plotCycleQuality <- function(df) 
{
    qnum <- as(SFastqQuality(as.character(df$Quality)), "numeric")
    df$qtot <- qnum * df$Count

    aveScore <- with(df,
                     tapply(qtot, list(lane, Cycle), sum) /
                     tapply(Count, list(lane, Cycle), sum))
    score <- data.frame(AverageScore=as.vector(aveScore),
                        Cycle=as.vector(col(aveScore)),
                        Lane=.laneLbl(rownames(aveScore)))
    xyplot(AverageScore~Cycle | Lane, score,
           ylab="Average score",
           aspect=2)
}
@ 

<<qa-run, echo=FALSE>>=
load("@QA_SAVE_FILE@")
@

\section{Reads}

Read counts. Filtered and aligned read counts are reported relative to
the total number of reads (clusters).
<<read-counts>>=
ppnCount(qa[["readCounts"]])
@

Base calls. Frequency of base calls over all reads.
<<base-calls>>=
qa[["baseCalls"]] / rowSums(qa[["baseCalls"]])
@ 

Overall read quality
<<read-quality-raw, fig=TRUE>>=
df <- qa[["readQualityScore"]]
print(plotReadQuality(df[df$type=="read",]))
@ 

Read distribution: occurrences
<<read-distribution-occurrence, fig=TRUE>>=
df <- qa[["sequenceDistribution"]]
print(plotReadOccurrences(df[df$type=="read",], cex=.5))
@ 

Common duplicate reads
<<common-duplicate-reads>>=
freqSequences(qa, "read")
@ 


Common duplicate reads after filtering
<<common-duplicate-mapped-reads>>=
freqSequences(qa, "filtered")
@

Per-cycle base call
<<per-cycle-base-call, fig=TRUE>>=
perCycle <- qa[["perCycle"]]
print(plotCycleBaseCall(perCycle$baseCall))
@ 

Per-cycle quality score. Reported quality scores are `calibrated',
i.e., incorporating phred-like adjustments following seuqence
alignment.
<<per-cycle-quality, fig=TRUE>>=
print(plotCycleQuality(perCycle$quality))
@ 

Counts per tile. 
<<counts-histo, fig=TRUE>>=
perTile <- qa[["perTile"]]
readCnt <- perTile[["readCounts"]]
cnts <- readCnt[readCnt$type=="read", "count"]
print(histogram(cnts, breaks=40, xlab="Reads per tile"))
@ 

Number of tiles with fewer than 1, 5, and 10\% of reads.
<<counts-quantile>>=
quantile(cnts, c(.01, .05, .1))
@ 
% 
Spatial counts per tile. Divisions on the color scale are quantized,
so that the range of counts per tile is divided into 10 equal
increments. Parenthetic numbers on the scale represent the break
points of the quantized values.
<<read-counts-per-tile, fig=TRUE>>=
print(plotTileCounts(readCnt[readCnt$type=="read",]))
@ 
 
Median read quality score per tile. Divisions on the color scale are
quantized, so that the range of average quality scores per tile is
divided into 10 equal increments. Parenthetic numbers on the scale
represent the break points of the quantized values.
<<read-score-per-tile, fig=TRUE>>=
qscore <- perTile[["medianReadQualityScore"]]
print(plotTileQualityScore(qscore[qscore$type=="read",]))
@

Mapped alignment score. Counts measured relative to counts in score
category with maximum representation.
<<mapped-alignment-score, fig=TRUE>>=
print(plotAlignQuality(qa[["alignQuality"]]))
@ 

\appendix

\section{Report-specific functions}

<<appendix,keep.source=TRUE>>=
<<utilities>>
@

\end{document}
